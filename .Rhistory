x <- runif(1, L, U)
}
x
}
# Fix n_i:
non.na.ind <- !is.na(N_i[1, ])
J <- ifelse(is.null(ncol(N_i)), length(N_i), ncol(N_i))
n_i <- N_i[, !is.na(N_i[1, ])]
if (is.null(nrow(n_i))) {
n_i <- array(n_i, dim = c(1, length(n_i)))
}
K <- ifelse(is.null(nrow(n_i)), 1, nrow(n_i))
# Set prior parameters:
prior.alpha <- rep(prior.alpha, ncol(n_i))
beta <- beta_sav <- .9
delta <- delta_sav <- 0.01
sigma <- 1:K
k_rep <- floor(K / 2)
## Get initial values for alpha and gamma
alpha <- array(NA, dim = c(1, ncol(n_i)))
alpha[1, ] <- rep(1 / ncol(n_i), ncol(n_i))
z <- alpha_to_z(log(alpha))
z_1m <- sapply(z, log1mexp)
gamma <- gamma_sav <- 5#rgamma(1, g.a, g.b)
tables <- matrix(c(1, 1), nrow = 2)
group_alloc <- 1
groupings_sav <- array(NA, dim = c(B, nrow(n_i)))
alpha_sav <- array(NA, dim = c(B, ncol(n_i)))
theta_sav <- array(NA, dim = c(B, K, ncol(n_i)))
# Possible partitions:
if(K <= 13){
p <- salso::enumerate.partitions(K)
groupings <- p[sample(1:nrow(p), 1), ]
} else {
num_groups <- sample(1:K, 1)
groupings <- sample(1:num_groups, K, replace = TRUE)
}
# Reorder by counts:
max.col <- which.max(apply(n_i, 2, sum))
n_i <- n_i[ , c(c(1:length(n_i[1,]))[-max.col], max.col)]
b <- 2
## Update groupings:
if (method == "aao") {
groupings <- update_groupings_aao(p,
beta,
delta,
dist,
sigma,
alpha,
gamma,
n_i,
prior.alpha,
g.a,
g.b,
K)
} else{
groupings <- update_groupings_seq(n_i,
groupings,
alpha,
gamma,
beta,
delta,
sigma,
dist,
prior.alpha,
g.a,
g.b,
K)
}
p
## Update groupings:
if (method == "aao") {
groupings <- update_groupings_aao(p,
beta,
delta,
dist,
sigma,
alpha,
gamma,
n_i,
prior.alpha,
g.a,
g.b,
K)
} else{
groupings <- update_groupings_seq(n_i,
groupings,
alpha,
gamma,
beta,
delta,
sigma,
dist,
prior.alpha,
g.a,
g.b,
K)
}
dim(prior.alpha)
prior.alpha
sum(prior.alpha)
prior.alpha <- prior.alpha[1]
## Update groupings:
if (method == "aao") {
groupings <- update_groupings_aao(p,
beta,
delta,
dist,
sigma,
alpha,
gamma,
n_i,
prior.alpha,
g.a,
g.b,
K)
} else{
groupings <- update_groupings_seq(n_i,
groupings,
alpha,
gamma,
beta,
delta,
sigma,
dist,
prior.alpha,
g.a,
g.b,
K)
}
prior.alpha
# Set prior parameters:
prior.alpha <- rep(prior.alpha, ncol(n_i))
prior.alpha
## Update groupings:
if (method == "aao") {
groupings <- update_groupings_aao(p,
beta,
delta,
dist,
sigma,
alpha,
gamma,
n_i,
prior.alpha,
g.a,
g.b,
K)
} else{
groupings <- update_groupings_seq(n_i,
groupings,
alpha,
gamma,
beta,
delta,
sigma,
dist,
prior.alpha,
g.a,
g.b,
K)
}
log.prior.probs <- apply(p, 1, \(x) log_epa_prior(x, beta, delta, dist, sigma))
log.prior.probs <- log.prior.probs - max(log.prior.probs)
## Update groupings:
log_probs <- apply(p,
1,
\(x) log_like_prob_group(n_i, x, alpha, gamma, prior.alpha, g.a, g.b, K))
log_probs <- log_probs - max(log_probs)
log_post_probs <- log_probs + log.prior.probs
log_post_probs <- log_post_probs - max(log_post_probs)
probs <- exp(log_post_probs) / sum(exp(log_post_probs))
p[sample(1:52, 1, prob = probs), ]
p[sample(1:length(p), 1, prob = probs), ]
length(probs)
length(p)
nrow(p)
p[sample(1:nrow(p), 1, prob = probs), ]
# Function to update groupings using the all at once method:
update_groupings_aao <- function(p,
beta,
delta,
dist,
sigma,
alpha,
gamma,
n_i,
prior.alpha,
g.a,
g.b,
K) {
log.prior.probs <- apply(p, 1, \(x) log_epa_prior(x, beta, delta, dist, sigma))
log.prior.probs <- log.prior.probs - max(log.prior.probs)
## Update groupings:
log_probs <- apply(p,
1,
\(x) log_like_prob_group(n_i, x, alpha, gamma, prior.alpha, g.a, g.b, K))
log_probs <- log_probs - max(log_probs)
log_post_probs <- log_probs + log.prior.probs
log_post_probs <- log_post_probs - max(log_post_probs)
probs <- exp(log_post_probs) / sum(exp(log_post_probs))
p[sample(1:nrow(p), 1, prob = probs), ]
}
## Update groupings:
if (method == "aao") {
groupings <- update_groupings_aao(p,
beta,
delta,
dist,
sigma,
alpha,
gamma,
n_i,
prior.alpha,
g.a,
g.b,
K)
} else{
groupings <- update_groupings_seq(n_i,
groupings,
alpha,
gamma,
beta,
delta,
sigma,
dist,
prior.alpha,
g.a,
g.b,
K)
}
## Update permutation (sigma):
sigma <- update_sigma(sigma, k_rep, groupings, beta, delta, dist)
## Update mass parameter:
beta <- update_beta(beta, groupings, delta, dist, sigma)
## Update discount parameter (delta):
delta <- update_delta(groupings, beta, delta, dist, sigma)
# Update gamma/alpha:
# Combine counts
n_curr <- combine_counts(groupings, n_i)
# Update gamma:
gamma <- exp(gamma_update(z, z_1m, ncol(n_i), n_i = n_curr, nrow(n_curr) , log(gamma), g.a, g.b))
# Update z:
z <- update_z(z,
z_1m,
ncol(n_i),
n_i = n_curr,
nrow(n_curr),
log(gamma),
unique(prior.alpha))
z_1m <- sapply(z, log1mexp)
# Translate to alpha:
alpha <- exp(alpha_map(z, z_1m))
# Thin:
if (b %% thin == 0) {
alpha_sav[b / thin, ] <- alpha[c(1:(max.col - 1), length(alpha), max.col:(length(alpha) - 1))]
groupings_sav[b / thin, ] <- groupings
gamma_sav[b / thin] <- gamma
beta_sav[b / thin] <- beta
delta_sav[b / thin] <- delta
for (g in unique(groupings)) {
ind <- which(groupings == g)
theta_sav[b / thin, ind, ] <- matrix(
rep(
LaplacesDemon::rdirichlet(1, n_curr[g, ] + alpha * gamma)[1, c(1:(max.col - 1), length(alpha), max.col:(length(alpha) - 1))],
length(ind)
),
nrow = length(ind),
byrow = T
)
}
}
length(alpha_sav[b/thin, ])
length(alpha)
max.col
1:0
# Reorder by counts:
max.col <- which.max(apply(n_i, 2, sum))
n_i <- n_i[ , c(c(1:length(n_i[1,]))[-max.col], max.col)]
subset <- ifelse(max.col == 1, c(length(alpha), max.col:(length(alpha) - 1)),
c(1:(max.col - 1), length(alpha), max.col:(length(alpha) - 1)))
## Update groupings:
if (method == "aao") {
groupings <- update_groupings_aao(p,
beta,
delta,
dist,
sigma,
alpha,
gamma,
n_i,
prior.alpha,
g.a,
g.b,
K)
} else{
groupings <- update_groupings_seq(n_i,
groupings,
alpha,
gamma,
beta,
delta,
sigma,
dist,
prior.alpha,
g.a,
g.b,
K)
}
## Update permutation (sigma):
sigma <- update_sigma(sigma, k_rep, groupings, beta, delta, dist)
## Update mass parameter:
beta <- update_beta(beta, groupings, delta, dist, sigma)
## Update discount parameter (delta):
delta <- update_delta(groupings, beta, delta, dist, sigma)
# Update gamma/alpha:
# Combine counts
n_curr <- combine_counts(groupings, n_i)
# Update gamma:
gamma <- exp(gamma_update(z, z_1m, ncol(n_i), n_i = n_curr, nrow(n_curr) , log(gamma), g.a, g.b))
# Update z:
z <- update_z(z,
z_1m,
ncol(n_i),
n_i = n_curr,
nrow(n_curr),
log(gamma),
unique(prior.alpha))
z_1m <- sapply(z, log1mexp)
# Translate to alpha:
alpha <- exp(alpha_map(z, z_1m))
# Thin:
if (b %% thin == 0) {
alpha_sav[b / thin, ] <- alpha[subset]
groupings_sav[b / thin, ] <- groupings
gamma_sav[b / thin] <- gamma
beta_sav[b / thin] <- beta
delta_sav[b / thin] <- delta
for (g in unique(groupings)) {
ind <- which(groupings == g)
theta_sav[b / thin, ind, ] <- matrix(
rep(
LaplacesDemon::rdirichlet(1, n_curr[g, ] + alpha * gamma)[1, subset],
length(ind)
),
nrow = length(ind),
byrow = T
)
}
}
# Fit HAMC model:
fit_hamc <- hamc(N, MCMC.cores = 1)
J <- sum(!is.na(n_i[1, ]))
# Fix dimension of n_i if only one group:
if (is.null(dim(n_i))) {
n_i <- matrix(n_i, nrow = 1)
}
# initialize gamma and alpha (log scale)
g <- c(log(1))
alpha <- array(NA, dim = c(B + 500, J))
n_i <- N[,1,]
J <- sum(!is.na(n_i[1, ]))
# Fix dimension of n_i if only one group:
if (is.null(dim(n_i))) {
n_i <- matrix(n_i, nrow = 1)
}
# initialize gamma and alpha (log scale)
g <- c(log(1))
alpha <- array(NA, dim = c(B + 500, J))
theta <- array(0, dim = c(B + 500, K, length(n_i[1, ])))
alpha[1, ] <- log(rep(1 / J, J))
for (k in 1:K) {
theta[1, k, !is.na(n_i[k, ])] <- LaplacesDemon::rdirichlet(1, exp(g[1] + alpha[1, ]) + n_i[k, ][!is.na(n_i[k, ])])
}
z <- z_1m <- psi <- array(NA, dim = c(B + 500, J - 1))
z[1, ] <- alpha_to_z(alpha[1, ])
psi[1, ] <- pbeta(exp(z[1, ]), .5, .5)
z_1m[1, ] <- sapply(z[1, ], log1mexp)
# Reorder by counts:
max.col <- which.max(apply(n_i, 2, sum))
n_i <- n_i[ , c(c(1:length(n_i[1,]))[-max.col], max.col)]
subset <- ifelse(max.col == 1, c(length(alpha), max.col:(length(alpha) - 1)),
c(1:(max.col - 1), length(alpha), max.col:(length(alpha) - 1)))
iter = 1
iter = 2
# Update Gamma:
# Slice:
g[iter] <- gamma_update(z[iter - 1, ], z_1m[iter - 1, ], J, n_i
, K, g[iter - 1], g.a, g.b)
# Update alpha:
## Map to z(beta) variables:
## Update z values (does accept/reject with slice sampler):
z[iter, ] <- update_z(z[iter - 1, ], z_1m[iter - 1, ], J, n_i = n_i
, K, g[iter], prior.alpha)
prior.alpha
prior.alpha = .2
# Update Gamma:
# Slice:
g[iter] <- gamma_update(z[iter - 1, ], z_1m[iter - 1, ], J, n_i
, K, g[iter - 1], g.a, g.b)
# Update alpha:
## Map to z(beta) variables:
## Update z values (does accept/reject with slice sampler):
z[iter, ] <- update_z(z[iter - 1, ], z_1m[iter - 1, ], J, n_i = n_i
, K, g[iter], prior.alpha)
psi[iter, ] <- pbeta(exp(z[iter, ]), .5, .5)
z_1m[iter, ] <- sapply(z[iter, ], log1mexp)
alpha[iter, ] <- alpha_map(z[iter, ], z_1m[iter, ])
for (k in 1:K) {
theta[iter, k, !is.na(n_i[k, subset])] <- LaplacesDemon::rdirichlet(1, exp(g[iter] + alpha[iter, subset]) + n_i[k, subset][!is.na(n_i[k, subset])])
}
alpha[iter,]
length(subset)
subset
# Reorder by counts:
max.col <- which.max(apply(n_i, 2, sum))
max.col
n_i <- N[,1,]
# Reorder by counts:
max.col <- which.max(apply(n_i, 2, sum))
max.col
n_i <- n_i[ , c(c(1:length(n_i[1,]))[-max.col], max.col)]
subset <- ifelse(max.col == 1, c(length(alpha), max.col:(length(alpha) - 1)),
c(1:(max.col - 1), length(alpha), max.col:(length(alpha) - 1)))
subset
max.col
ifelse(max.col == 1, c(length(alpha), max.col:(length(alpha) - 1)),
c(1:(max.col - 1), length(alpha), max.col:(length(alpha) - 1)))
alpha
subset <- ifelse(max.col == 1, c(length(alpha[1,]), max.col:(length(alpha[1,]) - 1)),
c(1:(max.col - 1), length(alpha[1,]), max.col:(length(alpha[1,]) - 1)))
subset
subset <- ifelse(max.col == 1, c(length(alpha[1,]), max.col:(length(alpha[1,]) - 1)),
c(1:(max.col - 1), length(alpha[1,]), max.col:(length(alpha[1,]) - 1)))
(length(alpha[1,]) - 1)
max.col
c(length(alpha[1,]), max.col:(length(alpha[1,] - 1)))
max.col == 1
subset <- ifelse(max.col == 1, c(length(alpha[1,]), max.col:(length(alpha[1,] - 1))),
c(1:(max.col - 1), length(alpha[1,]), max.col:(length(alpha[1,]) - 1)))
subset
ifelse(max.col == 1, c(length(alpha[1,]), max.col:(length(alpha[1,] - 1))),
c(1:(max.col - 1), length(alpha[1,]), max.col:(length(alpha[1,]) - 1)))
c(length(alpha[1,]), max.col:(length(alpha[1,] - 1)))
max.col:(length(alpha[1,] - 1))
length(alpha[1,]
subset <- ifelse(max.col == 1, c(length(alpha[1,]), max.col:(length(alpha[1,]) - 1)),
alpha[1,]
length(alpha[1,])
c(length(alpha[1,]), max.col:(length(alpha[1,]) - 1))
c(1:(max.col - 1), length(alpha[1,]), max.col:(length(alpha[1,]) - 1))
subset <- ifelse(max.col == 1, c(length(alpha[1,]), max.col:(length(alpha[1,]) - 1)),
c(1:(max.col - 1), length(alpha[1,]), max.col:(length(alpha[1,]) - 1)))
subset
ifelse(max.col == 1, c(length(alpha[1,]), max.col:(length(alpha[1,]) - 1)),
c(1:(max.col - 1), length(alpha[1,]), max.col:(length(alpha[1,]) - 1)))
alpha <- alpha[1,]
subset <- ifelse(max.col == 1, c(length(alpha), max.col:(length(alpha) - 1)),
c(1:(max.col - 1), length(alpha), max.col:(length(alpha) - 1)))
subset
ifelse(max.col == 1, c(length(alpha), max.col:(length(alpha) - 1)),
c(1:(max.col - 1), length(alpha), max.col:(length(alpha) - 1)))
max.col
max.col:(length(alpha) - 1))
if(max.col == 1){
subset <- c(length(alpha), max.col:(length(alpha) - 1))
} else{
subset <- c(1:(max.col - 1), length(alpha), max.col:(length(alpha) - 1))
}
subset
alpha <- array(NA, dim = c(B + 500, J))
theta <- array(0, dim = c(B + 500, K, length(n_i[1, ])))
alpha[1, ] <- log(rep(1 / J, J))
if(max.col == 1){
subset <- c(length(alpha[1,]), max.col:(length(alpha[1,]) - 1))
} else{
subset <- c(1:(max.col - 1), length(alpha[1,]), max.col:(length(alpha[1,]) - 1))
}
iter
# Update Gamma:
# Slice:
g[iter] <- gamma_update(z[iter - 1, ], z_1m[iter - 1, ], J, n_i
, K, g[iter - 1], g.a, g.b)
# Update alpha:
## Map to z(beta) variables:
## Update z values (does accept/reject with slice sampler):
z[iter, ] <- update_z(z[iter - 1, ], z_1m[iter - 1, ], J, n_i = n_i
, K, g[iter], prior.alpha)
psi[iter, ] <- pbeta(exp(z[iter, ]), .5, .5)
z_1m[iter, ] <- sapply(z[iter, ], log1mexp)
alpha[iter, ] <- alpha_map(z[iter, ], z_1m[iter, ])
for (k in 1:K) {
theta[iter, k, !is.na(n_i[k, subset])] <- LaplacesDemon::rdirichlet(1, exp(g[iter] + alpha[iter, subset]) + n_i[k, subset][!is.na(n_i[k, subset])])
}
# Start MCMC:
for (iter in 2:(B + 500)) {
# Update Gamma:
# Slice:
g[iter] <- gamma_update(z[iter - 1, ], z_1m[iter - 1, ], J, n_i
, K, g[iter - 1], g.a, g.b)
# Update alpha:
## Map to z(beta) variables:
## Update z values (does accept/reject with slice sampler):
z[iter, ] <- update_z(z[iter - 1, ], z_1m[iter - 1, ], J, n_i = n_i
, K, g[iter], prior.alpha)
psi[iter, ] <- pbeta(exp(z[iter, ]), .5, .5)
z_1m[iter, ] <- sapply(z[iter, ], log1mexp)
alpha[iter, ] <- alpha_map(z[iter, ], z_1m[iter, ])
for (k in 1:K) {
theta[iter, k, !is.na(n_i[k, subset])] <- LaplacesDemon::rdirichlet(1, exp(g[iter] + alpha[iter, subset]) + n_i[k, subset][!is.na(n_i[k, subset])])
}
}
