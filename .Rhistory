p[sample(1:nrow(p), 1, prob = probs), ]
}
# Function for sequential group update:
update_groupings_seq <- function(n_i,
groupings,
alpha,
gamma,
beta,
delta,
sigma,
dist,
prior.alpha,
g.a,
g.b,
K) {
count = 0
for (i in sample(1:K)) {
alloc <- groupings[-i]
# Combine n's:
ids <- (unique(alloc))
res <- lapply(ids, function(id)
sort(c(1:K)[-i][alloc == id]))
names(res) <- 1:length(res)
counts.list <- lapply(res, \(x) {
if (length(x) == 1) {
n_i[x, ]
}
else{
colSums(n_i[x, ])
}
})
n_curr <- matrix(unlist(counts.list),
nrow = length(res),
byrow = T)
# Get log_post probabilities.
log_probs <- log_lik <- log_prior <- c()
for (j in 1:(length(ids) + 1)) {
n_use <- n_curr
p_use <- numeric(K)
p_use[i] <- j
for (g in 1:length(ids)) {
p_use[res[[g]]] <- g
}
if (j != length(ids) + 1) {
n_use[j, ] <- n_use[j, ] + n_i[i, ]
} else{
n_use <- rbind(n_use, n_i[i, ])
}
log_lik[j] <- log_full_joint(n_use, alpha, gamma, prior.alpha, g.a, g.b)
log_prior[j] <- log_epa_prior(p_use, beta, delta, dist, sigma)
}
log_lik <- log_lik - max(log_lik)
log_prior <- log_prior - max(log_prior)
log_probs <- log_lik + log_prior
log_probs <- log_probs - max(log_probs)
probs <- exp(log_probs) / sum(exp(log_probs))
n_g <- sample(1:(length(ids) + 1), 1, prob = probs)
alloc.new <- numeric(K)
for (j in 1:length(ids)) {
alloc.new[res[[j]]] <- j
}
alloc.new[i] <- n_g
groupings <- alloc.new
}
groupings
}
# Update permutation:
update_sigma <- function(sigma, k_rep, grouping, beta, delta, dist) {
sigma_prop <- sigma
ind <- sample(1:length(sigma), k_rep)
sigma_prop[ind] <- sample(sigma_prop[ind])
# accept/reject:
a <- log_epa_prior(grouping, beta, delta, dist, sigma_prop) -
log_epa_prior(grouping, beta, delta, dist, sigma)
if (a > log(runif(1))){
prop <- sigma_prop
} else{
prop <- sigma
}
prop
}
# Update mass parameter (beta):
update_beta <- function(beta, grouping, delta, dist, sigma) {
beta_prop <- beta + rnorm(1, mean = 0, sd = .5)
a <- log_epa_prior(grouping, beta_prop, delta, dist, sigma) + dgamma(beta_prop, 3, 5, log = T) -
log_epa_prior(grouping, beta, delta, dist, sigma) - dgamma(beta, 3, 5, log = T)
if (a > log(runif(1))) {
prop <- beta_prop
} else{
prop <- beta
}
prop
}
# Update discount parameter (delta):
update_delta <- function(grouping, beta, delta, dist, sigma) {
# Stepping in Slice Sampler:
L <- 0
U <- 1
f_x <- exp(log_epa_prior(grouping, beta, delta, dist, sigma) + log_delta_prior(delta))
y <- runif(1, 0, f_x)
x <- runif(1, L, U)
while (log(y) > log_epa_prior(grouping, beta, x, dist, sigma) + log_delta_prior(x)) {
if (x < delta) {
L = x
} else{
U = x
}
x <- runif(1, L, U)
}
x
}
# Function to run MCMC:(methods = aao or seq)
epa_mcmc <- function(N_i,
B = 10000,
thin = 1,
method = "aao",
prior.alpha,
g.a,
g.b,
dist) {
# Fix n_i:
non.na.ind <- !is.na(N_i[1, ])
J <- sum(non.na.ind)#ifelse(is.null(ncol(N_i)), length(N_i), ncol(N_i))
n_i <- N_i[, !is.na(N_i[1, ])]
if (is.null(nrow(n_i))) {
n_i <- array(n_i, dim = c(1, length(n_i)))
}
K <- ifelse(is.null(nrow(n_i)), 1, nrow(n_i))
# Set prior parameters:
prior.alpha <- rep(prior.alpha, ncol(n_i))
beta <- beta_sav <- .9
delta <- delta_sav <- 0.01
sigma <- 1:K
k_rep <- floor(K / 2)
psi <- array(0, dim = c(B, ncol(n_i)-1))
## Get initial values for alpha and gamma
alpha <- array(NA, dim = c(1, ncol(n_i)))
alpha[1, ] <- rep(1 / ncol(n_i), ncol(n_i))
z <- alpha_to_z(log(alpha))
z_1m <- sapply(z, log1mexp)
gamma <- gamma_sav <- 5#rgamma(1, g.a, g.b)
tables <- matrix(c(1, 1), nrow = 2)
group_alloc <- 1
groupings_sav <- array(NA, dim = c(B, nrow(n_i)))
alpha_sav <- array(NA, dim = c(B, ncol(n_i)))
theta_sav <- array(NA, dim = c(B, K, ncol(n_i)))
# Possible partitions:
if(K <= 13){
p <- salso::enumerate.partitions(K)
groupings <- p[sample(1:nrow(p), 1), ]
} else {
num_groups <- sample(1:K, 1)
groupings <- sample(1:num_groups, K, replace = TRUE)
}
# Reorder by counts:
max.col <- which.max(apply(n_i, 2, sum))
n_i <- n_i[ , c(c(1:length(n_i[1,]))[-max.col], max.col)]
if(max.col == 1){
subset <- c(length(alpha), max.col:(length(alpha) - 1))
} else if(max.col == length(alpha)){
subset <- 1:length(alpha)
}else{
subset <- c(1:(max.col - 1), length(alpha), max.col:(length(alpha) - 1))
}
# Run MCMC:
# prior probs of partitions:
# Run MCMC:
for (b in 2:(B * thin)) {
## Update groupings:
if (method == "aao") {
groupings <- update_groupings_aao(p,
beta,
delta,
dist,
sigma,
alpha,
gamma,
n_i,
prior.alpha,
g.a,
g.b,
K)
} else{
groupings <- update_groupings_seq(n_i,
groupings,
alpha,
gamma,
beta,
delta,
sigma,
dist,
prior.alpha,
g.a,
g.b,
K)
}
## Update permutation (sigma):
sigma <- update_sigma(sigma, k_rep, groupings, beta, delta, dist)
## Update mass parameter:
beta <- update_beta(beta, groupings, delta, dist, sigma)
## Update discount parameter (delta):
delta <- update_delta(groupings, beta, delta, dist, sigma)
# Update gamma/alpha:
# Combine counts
n_curr <- combine_counts(groupings, n_i)
# Update gamma:
gamma <- exp(gamma_update(z, z_1m, ncol(n_i), n_i = n_curr, nrow(n_curr) , log(gamma), g.a, g.b))
# Update z:
z <- update_z(z,
z_1m,
ncol(n_i),
n_i = n_curr,
nrow(n_curr),
log(gamma),
unique(prior.alpha))
z_1m <- sapply(z, log1mexp)
# Translate to alpha:
alpha <- exp(alpha_map(z, z_1m))
# Thin:
if (b %% thin == 0) {
alpha_sav[b / thin, ] <- alpha[subset]
groupings_sav[b / thin, ] <- groupings
gamma_sav[b / thin] <- gamma
beta_sav[b / thin] <- beta
delta_sav[b / thin] <- delta
for (g in unique(groupings)) {
ind <- which(groupings == g)
theta_sav[b / thin, ind, ] <- matrix(
rep(
LaplacesDemon::rdirichlet(1, n_curr[g, ] + alpha * gamma)[1, subset],
length(ind)
),
nrow = length(ind),
byrow = T
)
}
}
}
J <- ifelse(is.null(ncol(N_i)), length(N_i), ncol(N_i))
alpha <- array(0, dim = c(B, J))
alpha[, non.na.ind] <- alpha_sav
theta <- array(0, dim = c(B, K, J))
theta[, , non.na.ind] <- theta_sav
return(
list(
groups = groupings_sav,
alpha = alpha,
gamma = gamma_sav,
theta = theta,
psi = psi,
beta = beta_sav,
delta = delta_sav
)
)
}
## Function for HAMC MCMC:
hamc_mcmc <- function(N_i, K, g.a, g.b, prior.alpha, B) {
J <- sum(!is.na(N_i[1, ]))
# Fix dimension of n_i if only one group:
if (is.null(dim(N_i))) {
N_i <- matrix(N_i, nrow = 1)
}
# initialize gamma and alpha (log scale)
g <- c(log(1))
alpha <- array(NA, dim = c(B, J))
theta <- array(0, dim = c(B, K, J))
alpha[1, ] <- log(rep(1 / J, J))
for (k in 1:K) {
theta[1, k, ] <- LaplacesDemon::rdirichlet(1, exp(g[1] + alpha[1, ]) + N_i[k, ][!is.na(N_i[k, ])])
}
z <- z_1m <- psi <- array(NA, dim = c(B, J - 1))
z[1, ] <- alpha_to_z(alpha[1, ])
psi[1, ] <- pbeta(exp(z[1, ]), .5, .5)
z_1m[1, ] <- sapply(z[1, ], log1mexp)
# Reorder by counts:
n_i <- N_i[,!is.na(N_i[1, ])]
max.col <- which.max(apply(n_i, 2, sum))
n_i <- n_i[ , c(c(1:length(n_i[1,]))[-max.col], max.col)]
if(max.col == 1){
subset <- c(length(alpha[1, ]), max.col:(length(alpha[1, ]) - 1))
} else if(max.col == length(alpha[1, ])){
subset <- 1:length(alpha[1, ])
}else{
subset <- c(1:(max.col - 1), length(alpha[1, ]), max.col:(length(alpha[1, ]) - 1))
}
# Start MCMC:
for (iter in 2:(B)) {
# Update Gamma:
# Slice:
g[iter] <- gamma_update(z[iter - 1, ], z_1m[iter - 1, ], J, n_i
, K, g[iter - 1], g.a, g.b)
# Update alpha:
## Map to z(beta) variables:
## Update z values (does accept/reject with slice sampler):
z[iter, ] <- update_z(z[iter - 1, ], z_1m[iter - 1, ], J, n_i = n_i
, K, g[iter], prior.alpha)
psi[iter, ] <- pbeta(exp(z[iter, ]), .5, .5)
z_1m[iter, ] <- sapply(z[iter, ], log1mexp)
alpha[iter, ] <- alpha_map(z[iter, ], z_1m[iter, ])
for (k in 1:K) {
theta[iter, k, ] <- LaplacesDemon::rdirichlet(1, exp(g[iter] + alpha[iter, subset]) + n_i[k, subset])
}
}
# Save row draws:
alpha_draws <- array(0, dim = c(B, length(N_i[1, ])))
theta_draws <- array(0, dim = c(B, K, length(N_i[1, ])))
alpha_draws[, !is.na(n_i[1, ])] <- exp(alpha[, subset])
gamma_draws <- exp(g)
theta_draws[ , , !is.na(N_i[1, ])] <- theta[, , subset]
#print(i)
return(list(
alpha = alpha_draws,
gamma = gamma_draws,
theta = theta_draws,
psi = psi
))
}
# Fit HAMC model:
fit_hamc <- hamc(N, MCMC.cores = 1)
3*4*5
47/60 + 9/80
1/10*.5
1/10*1.25
47/60
2/10+2/6+2/8
10*(1-5/20-5/16-2/6)
1/60
i <- 10
slice_deg <- i
while(sum(slice_deg) < 360){
i <- i * 1.22
slice_deg <- c(slice_deg,i)
}
sum(slice_deg)
length(slice_deg)
sum(slice_deg[1:11])
slice_deg
slice_deg[4] + slice_deg[8]
(slice_deg[4] + slice_deg[8])/360
.25*pi*100 * (slice_deg[4] + slice_deg[8])/360
60/(60/72 - 1/60)
N
## Find Bugs:
I <- 10
J <- 13
K <- 5
P <- array(data = NA, dim = c(K, J))
i <- 1
group_ind <- 1:K
P[group_ind, ] <- matrix(rep(LaplacesDemon::rdirichlet(K, c(rep(I, J)))),
nrow = K,
ncol = J,
byrow = T)
N <- array(0, dim = c(K, 1, J))
for(k in 1:K){
seq <- sample(1:J, 150, prob = P[k,  ], replace = T)
N[k,  1, as.data.frame(table(seq))$seq] <- as.data.frame(table(seq))$Freq
}
# Check compatability of N:
d <- dim(N)
d
N_new <- array(NA, dim = c(d[2], d[3]))
for (i in 1:d[2]) {
N_new[i, ] <- colSums(N[, i, ], na.rm = TRUE)
}
N_new
colSums(N[,1,])
I <- nrow(N)
J <- ncol(N)
I
J
N <- N_new
I <- nrow(N)
J <- ncol(N)
I
J
## Get posterior draws amc:
theta <- array(0, dim = c(B, 1, J))
## Get posterior draws amc:
B <- 10000
theta <- array(0, dim = c(B, 1, J))
xsi <- rep(1/J, I)
## Get posterior draws amc:
B <- 10000
theta <- array(0, dim = c(B, 1, J))
xsi <- rep(1/J, I)
theta[, 1, ] <- LaplacesDemon::rdirichlet(B, colSums(N)[1,] + xsi)
N <- array(0, dim = c(K, 1, J))
for(k in 1:K){
seq <- sample(1:J, 150, prob = P[k,  ], replace = T)
N[k,  1, as.data.frame(table(seq))$seq] <- as.data.frame(table(seq))$Freq
}
## Get posterior draws amc:
B <- 10000
theta <- array(0, dim = c(B, 1, J))
xsi <- rep(1/J, I)
theta[, 1, ] <- LaplacesDemon::rdirichlet(B, colSums(N[,1,])[1,] + xsi)
colSums(N[,1,])
theta[, 1, ] <- LaplacesDemon::rdirichlet(B, colSums(N[,1,]) + xsi)
## Fit HAMC model
hamc_time <- system.time({hamc_res <- hamc(N)})
library(amcModels)
## Fit HAMC model
hamc_time <- system.time({hamc_res <- hamc(N)})
P_mean <- function(draws, K, J){
p_mean <- array(NA, dim = c(K, J))
for(k in 1:K){
if(length(dim(draws)) == 3){
p_mean[k,  ] <- mean(draws[ , 1, ])
} else{
p_mean[k, ] <- colMeans(draws[ , k, 1, ])
}
}
p_mean
}
MSE_P <- function(P, draws, J, K){
p_mean <- P_mean(draws, K, J)
norm((P - p_mean), type = "F")^2/(K*J)
}
MSE_P(P, theta, J, K)
MSE_P(P, hamc_res$theta, J, K)
## Find Bugs:
I <- 10
J <- 13
K <- 5
P <- array(data = NA, dim = c(K, J))
i <- 1
group_ind <- 1:K
P[group_ind, ] <- matrix(rep(LaplacesDemon::rdirichlet(K, c(rep(I, J)))),
nrow = K,
ncol = J,
byrow = T)
N <- array(0, dim = c(K, 1, J))
for(k in 1:K){
seq <- sample(1:J, 150, prob = P[k,  ], replace = T)
N[k,  1, as.data.frame(table(seq))$seq] <- as.data.frame(table(seq))$Freq
}
library(amcModels)
## Fit AMC model
## Get posterior draws amc:
B <- 10000
theta <- array(0, dim = c(B, 1, J))
xsi <- rep(1/J, I)
theta[, 1, ] <- LaplacesDemon::rdirichlet(B, colSums(N[,1,]) + xsi)
amc_time <- system.time({amc_res <- amc(N)})
## Fit HAMC model
hamc_time <- system.time({hamc_res <- hamc(N)})
## Fit EPA-HAMC model
#epahamc_time <- system.time({epahamc_res <- epa_hamc(N, method = "seq", thin = 5)})
P_mean <- function(draws, K, J){
p_mean <- array(NA, dim = c(K, J))
for(k in 1:K){
if(length(dim(draws)) == 3){
p_mean[k,  ] <- mean(draws[ , 1, ])
} else{
p_mean[k, ] <- colMeans(draws[ , k, 1, ])
}
}
p_mean
}
MSE_P <- function(P, draws, J, K){
p_mean <- P_mean(draws, K, J)
norm((P - p_mean), type = "F")^2/(K*J)
}
MSE_P(P, theta, J, K)
MSE_P(P, hamc_res$theta, J, K)
## Find Bugs:
I <- 10
J <- 13
K <- 5
P <- array(data = NA, dim = c(K, J))
i <- 1
group_ind <- 1:K
P[group_ind, ] <- matrix(rep(LaplacesDemon::rdirichlet(K, c(rep(I, J)))),
nrow = K,
ncol = J,
byrow = T)
N <- array(0, dim = c(K, 1, J))
for(k in 1:K){
seq <- sample(1:J, 150, prob = P[k,  ], replace = T)
N[k,  1, as.data.frame(table(seq))$seq] <- as.data.frame(table(seq))$Freq
}
library(amcModels)
## Fit AMC model
## Get posterior draws amc:
B <- 10000
theta <- array(0, dim = c(B, 1, J))
xsi <- rep(1/J, J)
theta[, 1, ] <- LaplacesDemon::rdirichlet(B, colSums(N[,1,]) + xsi)
amc_time <- system.time({amc_res <- amc(N)})
## Fit HAMC model
hamc_time <- system.time({hamc_res <- hamc(N)})
## Fit EPA-HAMC model
#epahamc_time <- system.time({epahamc_res <- epa_hamc(N, method = "seq", thin = 5)})
P_mean <- function(draws, K, J){
p_mean <- array(NA, dim = c(K, J))
for(k in 1:K){
if(length(dim(draws)) == 3){
p_mean[k,  ] <- mean(draws[ , 1, ])
} else{
p_mean[k, ] <- colMeans(draws[ , k, 1, ])
}
}
p_mean
}
MSE_P <- function(P, draws, J, K){
p_mean <- P_mean(draws, K, J)
norm((P - p_mean), type = "F")^2/(K*J)
}
MSE_P(P, theta, J, K)
MSE_P(P, hamc_res$theta, J, K)
?expm1
